// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package httpx

import (
	"sync"
)

// Ensure, that SensitiveDataMaskerMock does implement sensitiveDataMasker.
// If this is not the case, regenerate this file with moq.
var _ sensitiveDataMasker = &SensitiveDataMaskerMock{}

// SensitiveDataMaskerMock is a mock implementation of sensitiveDataMasker.
//
//	func TestSomethingThatUsessensitiveDataMasker(t *testing.T) {
//
//		// make and configure a mocked sensitiveDataMasker
//		mockedsensitiveDataMasker := &SensitiveDataMaskerMock{
//			MaskFunc: func(bytes []byte) []byte {
//				panic("mock out the Mask method")
//			},
//		}
//
//		// use mockedsensitiveDataMasker in code that requires sensitiveDataMasker
//		// and then make assertions.
//
//	}
type SensitiveDataMaskerMock struct {
	// MaskFunc mocks the Mask method.
	MaskFunc func(bytes []byte) []byte

	// calls tracks calls to the methods.
	calls struct {
		// Mask holds details about calls to the Mask method.
		Mask []struct {
			// Bytes is the bytes argument value.
			Bytes []byte
		}
	}
	lockMask sync.RWMutex
}

// Mask calls MaskFunc.
func (mock *SensitiveDataMaskerMock) Mask(bytes []byte) []byte {
	if mock.MaskFunc == nil {
		panic("SensitiveDataMaskerMock.MaskFunc: method is nil but sensitiveDataMasker.Mask was just called")
	}
	callInfo := struct {
		Bytes []byte
	}{
		Bytes: bytes,
	}
	mock.lockMask.Lock()
	mock.calls.Mask = append(mock.calls.Mask, callInfo)
	mock.lockMask.Unlock()
	return mock.MaskFunc(bytes)
}

// MaskCalls gets all the calls that were made to Mask.
// Check the length with:
//
//	len(mockedsensitiveDataMasker.MaskCalls())
func (mock *SensitiveDataMaskerMock) MaskCalls() []struct {
	Bytes []byte
} {
	var calls []struct {
		Bytes []byte
	}
	mock.lockMask.RLock()
	calls = mock.calls.Mask
	mock.lockMask.RUnlock()
	return calls
}
